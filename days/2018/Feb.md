Feb. 2018
===

## 02/01, Thu.

### 技術

* [I get paid for code that works, not for tests.](https://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests/153565#153565)：Kent Beck在SO的一則回覆：在對程式碼有足夠信心的狀況下，盡可能減少測試。如果覺得會有錯，就寫測試；但如果很有信心，或者認為不會在這麼簡單的地方犯錯，就不一定要寫測試。當然從另一個角度來思考，寫測試並不只是確保不會犯錯，同時也是減少修改程式碼的不確定性，所以這個說法不一定完全有道理...

## 02/02, Fri.

### 技術

* *單元測試的藝術*：編寫可讀的測試
    * 命名，至少要包含：
        * 被測試的單元/方法名稱
        * 測試的場景/條件
        * 期待的結果
    * 將斷言和操作分開，不要放在同一行。
    * 其實就跟平常寫程式碼一樣啦，魔術數字、減少不必要的重複等等原則仍然適用。

## 02/03, Sat.

### 技術

* [Best Practices for Modals / Overlays / Dialog Windows](https://heydesigner.com/blog/best-practices-modals-overlays-dialog-windows/) 講到modal的幾個設計的點：
    * 請把它放在畫面的上方––放太下面的話(正中間)有可能會因為device的高度不足而擋住內容。尺寸請維持在螢幕的50%以下，否則會讓用戶以為跳到新的頁面。
    * 允許用戶使用鍵盤操作，包括focus trap、esc key跳出等等。
    * 要有明顯的關閉按鈕，雖然設計者可能以為用戶會知道按modal外面就可以跳出去，但其實大家還是習慣有按鈕。
    * 允許用戶點按modal外面時可以跳出modal。
    * 標題、內容和按鈕要相符，讓用戶一眼看出來這個modal的用處。
    * 加上適當的backdrop，太暗的話用戶以為跳到別的頁面去了；太亮的話反而modal變的不明顯。
    * 行動裝置使用modal要小心，內容不可以多到超過畫面，操作時也避免讓用戶需要額外放大modal上的UI。
* 承上，[Overuse of Overlays](https://www.nngroup.com/articles/overuse-of-overlays/)則提到了什麼時候使用modal的時機和小問題：
    * 從動作來考慮，modal一般有三個用途：(1)看詳細內容(2)填表單(3)做決定
        * 詳細內容：如果它的內容足夠多以致於你需要加scroll bar，或許可以考慮做成另外一頁；或者，就算要用scroll bar，也要確保此時用戶不會誤觸原頁面的scroll bar，否則用戶可能為了滾動modal的scroll bar而不小心滾動了原頁面的內容。最後，還要考慮如何分享/收藏modal的內容，考慮modal該如何對應url。
        * 填表單：把取消鈕做的明顯一些(可以看裡面的反例)；另外，保留用戶的輸入，讓不小心跳出modal的用戶可以迅速恢復。
        * 做決定：類似於原生的`confirm`對話框。因為用戶通常被大量不重要又煩人的confirm對話框轟炸過，他們常常會連上面的文字都不仔細看就按確認，所以，請把確認鈕做得獨特一點，並且包含對將要發生的事情的敘述(刪除、變更、取消...)。
    * 什麼時間應該出現modal？請盡可能在用戶作了某些操作的狀況下才出現modal，非必要不要自動彈modal(對我就是在說你全版廣告)。裡面提了一個例子是網站在用戶要移動到其它網站時，主動跳modal做銷售，但我還是覺得這很惱人啊。
    * 為什麼這個內容應該放modal而不是獨立的頁面？有三個原因：(1)用戶的操作會導致嚴重而不可恢復的後果(刪東西、改變密碼)(2)網站需要必要的資訊下一步(3)內容很緊急又重要
        * 嚴重後果：請確認真的是很嚴重的後果。並且，針對重複性的作業，應該提供一個 Don't ask me again的checkbox。
        * 收集資訊：也就是上述的填寫表單，同樣，請確認是否真的需要收集這些資訊。
        * 緊急內容：這個緊急對誰而言緊急(用戶/網站/行銷)？什麼時候？一般而言，當網站和用戶站在同一個立場上時，比較可以出於緊急的理由使用modal(例如環境保護的募款、限時的倡議活動...)。
        * 那個，「我們用modal的話可以少設計一個頁面」之類的理由就算了吧。

## 02/04, Sun.

### 技術

* [Let’s make multi-colored icons with SVG symbols and CSS variables](https://medium.freecodecamp.org/lets-make-your-svg-symbol-icons-multi-colored-with-css-variables-cddd1769fca4)：用css variable來達成一組svg多種不同配色的目的。這是icon font做不到的事情之一唷。

## 02/05, Mon.

### 抬頭一望，也寫了一個月呢

其實還蠻累的。來談談一些困難吧。

最困難的還是**找到固定寫筆記的時間**吧。最前面是挑晚上回家之後寫，剛開始還新鮮所以很有成就感，但是晚回家的日子就傷腦筋了，想著不能斷更所以硬著頭皮寫，寫完常常都很晚了，隔天起床精神就會不好，工作進入狀況的速度慢了許多。

之後則是想著改成早上出門前來寫，但只要是晚回家晚睡覺的日子，早上就很難準時爬起來寫，加上天氣冷，就會更想賴床。

而且**並不是每天都有時間騰出來「好好」讀一些材料**。平日能夠讀東西的時間，大致上只有早上、搭車上下班和晚上回家後了。早上想賴床，搭車上班想補眠，晚上有事情，搭車回家累到不想讀，哼哈哈哈，真是完美的一天(咦)。誰叫我家離公司一小時遠呢。

再者，**不是每一篇文章都有料**，一個月下來，網路文章和書本比起來，書本還是能找到最多收穫的來源，特別是特定領域的經典書。網路上的文章有用的，多半是一些小技巧(例如前不久提到的實作多顏色svg icon)或跟框架有相關的概念/實作(例如redux duck type)，然而讀下來發現沒什麼內容的狀況也不少。但是困擾的是，實體的技術書籍多半都有一點高度或厚度，不是可以輕鬆帶著走的東西，所以就沒辦法想讀就讀了。結果，如果那天像上面說的沒什麼時間讀書，就只好趁搭車的時候讀網路文章了，而有些可能是地雷，最後發現比較有收穫的，反而都是些跟UI比較有關的內容XD

抱怨完了，來談談好處。每天做筆記最棒的地方是**它讓你看到一天、一個禮拜、半個月下來到底學了多少東西**。我常常對學了多少東西感到很不踏實，筆記記下的內容雖然不是全部，但確實是我下班時間學到的(跟技術相關)東西的...至少七八成有吧。它讓你看到一個禮拜可以累積的知識的量，讓你知道，超英趕美不可能，但每天累積還是可以有一些小成就。相對心裡會踏實一點。

還有一點不自言的好處是，**每天都會學到一點東西**，扣掉作者公休什麼的，為了不讓習慣斷掉，你總會去找一點東西來讀，所以一定會有所得。只是，這個所得是不是真的那麼值，就不一定了。零碎時間的理解多半想得不夠深，我覺得最有所得的時候，還是在那些能夠認真讀個二三十分鐘的好書的時候啊。

結論啊，果然是像[深度工作力](http://www.books.com.tw/products/0010758381)說的，要開出一段無人打擾的時間專注才行呢。

簡單的說：

* 要有固定時間，或至少每天都要排出可以專心的一段時間。
* 就想法的所得而言，書比網路文章要多而且也比較深入。不過框架用法、開發/建置工具、瀏覽器特性等等還是要讀網路文章。

也在思考以我的生活形態，到底應不應該每天都更新呢？如果有辦法，其實還是該每天空出一段時間的，但不管起床或睡前，看來也是得花點工夫呢，人生啊到底該不該這麼累呢(離題)。

## 02/06, Tue.

### 技術

* 回去讀了[Clean Code](http://www.books.com.tw/products/0010579897)的前三章。
    * 其實大多數的事都是知道的，可是回到實際工作上，還是很容易寫出`accountInfo`這樣的東西啊。
    * 關於匈牙利命名法(或任何夾帶型別的命名)，因為書中主要以Java/C#等等有靜態型別的語言為主，在想或許Javascript還是可以適用的...啊啊Typescript什麼的...
    * 倒是，命名有助於搜尋這件事情，好像是在工作一陣子之後才特別有感。沒好好命名的話真的很難找code啊。
    * 函數要抽象到舒服又看得懂的程度真的好難，現在還是常常劈哩啪啦的寫長長的函數QQ。第三章最後的範例我覺得很漂亮，可是說不定也會有人覺得抽太多了。

### 工作

* [Learning At Work](https://jvns.ca/blog/2017/08/06/learning-at-work/)：昨天才談到一點學習焦慮今天就在codeTengu上看到這篇了呢XD，談了一些在工作中學東西的方法。

### 趣聞

* [IFTTT](https://ifttt.com/)：可以把一堆服務串在一起的東西，還沒玩過但是好像很有趣，詳細一點的介紹看[這篇](https://www.computerworld.com/article/3239304/mobile-wireless/what-is-ifttt-how-to-use-if-this-then-that-services.html)

## 02/07, Wed.

### 技術

* 繼續讀Clean Code關於註解、編排、物件與資料結構的部分
    * 註解應當被視為一種為表達意圖失敗的彌補。它代表你想不出好方法用程式碼說出你的意圖，只好用註解了。整潔的程式碼本身具備一定的表達力，當想到使用註解時，很可能代表程式碼需要再弄乾淨。
    * 註解受人詬病的，就是沒辦法和程式碼一起被更新，註解一旦寫下去就可能成為將來的謊言，誤導或干擾將來負責維護的人。所以註解愈少愈好。
    * 檔案大小的範圍，盡可能不要超過一定的行數，以作者的專案Fitnesse來說，最大的檔案也不超過500行。而大多數的檔案少於200行。
    * 編排可以從垂直和水平的角度來劃分：
        * 垂直而言，由上而下按照函式呼叫的順序作編排，即被呼叫的函式放在呼叫它的函式的上面，如果抽象得當的話，讀它的人可以一路由最上層的抽象讀到底層。另外，相關的函式或局部變數應該要盡可能靠近被使用的地方。這些做法可以減少在檔案中不斷上下滑動瀏覽的窘境。
        * 水平而言，不要超過120個字元。其它縮排、留空等自不待言，Javascript可以交給 [prettier](https://prettier.io/)。

    * 結構化的寫法容易增加新的函式，但不容易增加新的資料型別；物件導向的寫法容易增加新的資料型別，但不容易增加新的函式。簡直像在繞口令嘛。`A.f()`和`f(A)`的差別呢...
    * **德摩特爾法則(The Law Of Demeter)**：一個類別C的方法f，應該只能呼叫以下事項的方法，否則就是事件知道了其它物件的內部運作：
        * C自身
        * 任何由f產生的物件
        * 作為參數傳給f的物件
        * C類別中實體變數持有的物件
    * 不是所有的東西都要寫成物件。而對於資料結構來說，違反德摩特爾法則則是ok的。
    
* [Software Complexity Is Killing Us](https://www.simplethread.com/software-complexity-killing-us/?utm_campaign=CodeTengu&utm_medium=email&utm_source=CodeTengu_115)：終究程式設計師的第一要務是創造價值，而不是去處理軟體複雜度(後者只是前者的一個面向)。作者的想法是，大多數的專案其實不需要那麼複雜的工具，而複雜的工具其實變相增加了開發的難度，讓開發者更難實作真正需要被實作的邏輯，開發的速度因此就變慢了。這很可能讓更多需要軟體的人轉向所謂的Low Code Platform，即不需要懂得寫程式，透過拖拉等簡單方式就可以建造軟體的平台。顯然，我們不會想要跟這些平台產生的code打交道，更嚴重的是，一旦平台本身倒了，產生的軟體可能也會跟著倒。仔細想想，前端現在也是愈來愈複雜，但是工作上碰到的需求，目前最多的也還是CRUD，簡單`$.ajax`一下就好的事情啊。先不論只是CRUD究竟能有什麼價值，我們真的有享受到新工具帶來的好處嗎？到底在什麼時候應該用____(可填入redux、react或任何新玩意兒)，什麼時候不需要呢？整體來說，我自己現在還是寫得挺舒服的，但是是該想一想呢。